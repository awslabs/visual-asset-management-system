# VAMS v2.3 to v2.4 Migration Guide

## Overview

This migration guide facilitates the upgrade from VAMS v2.3 to v2.4 by migrating constraints from the old `AuthEntitiesTable` to the new optimized `ConstraintsStorageTable`. The v2.4 release introduces a dedicated constraints table with Global Secondary Indexes (GSIs) for dramatically improved authorization performance.

## ‚ö†Ô∏è Important Note About Default Constraints

**If your deployment only contains the default constraints** (admin, basicReadOnly, basic, pipeline roles), **you do NOT need to run this migration script**. The CDK deployment automatically creates all default constraints in the new `ConstraintsStorageTable` during stack deployment.

**You only need to run this migration if:**

-   You have created custom constraints beyond the defaults
-   You have modified the default constraints
-   You have user-specific constraints (userPermissions)

**To check if you have custom constraints:**

```bash
aws dynamodb scan \
  --table-name your-AuthEntitiesTable \
  --filter-expression "entityType = :type AND NOT begins_with(constraintId, :prefix)" \
  --expression-attribute-values '{":type":{"S":"constraint"},":prefix":{"S":"initial_"}}' \
  --select COUNT
```

If the count is 0, you only have default constraints and can skip this migration.

## What's New in v2.4

### Performance Improvements

-   **20-100x faster constraint queries** using GSI instead of table scans
-   **30-60x faster authorization** with fixed cache expiration (30 seconds vs 15-30 minutes)
-   **Logarithmic query complexity** O(log n) instead of O(n)
-   **20-100x reduction in DynamoDB read capacity** usage

### Architecture Changes

-   **Dedicated Constraints Table**: Constraints moved from `AuthEntitiesTable` to `ConstraintsStorageTable`
-   **Optimized Schema**: Simple primary key (`constraintId`) instead of composite key
-   **JSON String Storage**: Complex fields stored as JSON strings for efficiency
-   **GSI Support**: Three GSIs for efficient querying:
    -   `GroupPermissionsIndex`: Query by role/group
    -   `UserPermissionsIndex`: Query by user
    -   `ObjectTypeIndex`: Query by object type

### Cache Bug Fix

-   **Fixed**: Enforcer cache now expires reliably every 30 seconds
-   **Before**: Cache persisted for 15-30 minutes (Lambda container lifetime)
-   **Impact**: Users' permissions now refresh within 30 seconds of role changes

## Migration Architecture

```
v2.3_to_v2.4_migration.py (Local script)
    ‚Üì
Read from AuthEntitiesTable
    - Query: entityType = 'constraint'
    - Scan all constraint items
    ‚Üì
Transform Data Format
    - Remove: entityType, sk
    - Convert arrays ‚Üí JSON strings
    - Extract StringSets for GSI (groupIds, userIds)
    - Add metadata fields
    ‚Üì
Write to ConstraintsStorageTable
    - Batch write operations (25 items per batch)
    - Use new optimized schema
    ‚Üì
Optional: Delete from AuthEntitiesTable
    - Only if --delete-old-data flag set
    - Batch delete operations
    - Safe to keep old data for rollback
```

## Prerequisites

### Required AWS Resources

1. **v2.4 CDK Stack Deployed**: The new `ConstraintsStorageTable` must exist
2. **Table Names**: Available from CloudFormation stack outputs

### Required IAM Permissions

```json
{
    "Version": "2012-01-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": ["dynamodb:Query", "dynamodb:Scan", "dynamodb:GetItem"],
            "Resource": "arn:aws:dynamodb:*:*:table/*AuthEntitiesTable*"
        },
        {
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:BatchWriteItem",
                "dynamodb:GetItem",
                "dynamodb:Scan"
            ],
            "Resource": "arn:aws:dynamodb:*:*:table/*ConstraintsStorageTable*"
        },
        {
            "Effect": "Allow",
            "Action": ["dynamodb:DeleteItem", "dynamodb:BatchWriteItem"],
            "Resource": "arn:aws:dynamodb:*:*:table/*AuthEntitiesTable*"
        }
    ]
}
```

**Note**: Delete permissions only needed if using `--delete-old-data` flag.

### Python Dependencies

```bash
pip install boto3
```

## Usage

### Step 1: Get Table Names

Get table names from CloudFormation stack outputs:

```bash
aws cloudformation describe-stacks \
  --stack-name your-vams-stack \
  --query 'Stacks[0].Outputs[?contains(OutputKey, `Table`)].{Key:OutputKey,Value:OutputValue}' \
  --output table
```

Look for:

-   `AuthEntitiesTableOutput` ‚Üí Source table
-   `ConstraintsStorageTableOutput` ‚Üí Target table (new in v2.4)

### Step 2: Configure Migration

**Option A: Using Configuration File (Recommended)**

1. Copy the template:

```bash
cp v2.3_to_v2.4_migration_config.json v2.3_to_v2.4_migration_prod_config.json
```

2. Edit `v2.3_to_v2.4_migration_prod_config.json`:

```json
{
    "auth_entities_table_name": "your-actual-auth-entities-table-name",
    "constraints_table_name": "your-actual-constraints-table-name",
    "delete_old_data": false,
    "dry_run": false,
    "limit": null,
    "aws_profile": null,
    "aws_region": "us-east-1",
    "log_level": "INFO"
}
```

**Option B: Using Command-Line Arguments**

All configuration can be provided via command-line arguments (see examples below).

### Step 3: Run Migration

#### Phase 1: Dry Run (Recommended First Step)

Test without making changes:

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --dry-run
```

#### Phase 2: Test with Limited Items

Test with a small subset:

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --limit 10 \
    --dry-run
```

#### Phase 3: Production Migration (Keeps Old Data)

Migrate all constraints (recommended - keeps old data for safety):

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable
```

#### Phase 4: Verify Migration

After migration, verify in VAMS:

1. Test user authorization with different roles
2. Check constraint management UI
3. Verify role assignments work correctly
4. Monitor CloudWatch logs for authorization queries

#### Phase 5: Optional Cleanup (After Verification)

Delete old constraint data (only after thorough verification):

```bash
# Dry run deletion first
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --delete-old-data \
    --dry-run

# Actual deletion
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --delete-old-data
```

### Using Configuration File

```bash
# With config file
python v2.3_to_v2.4_migration.py --config v2.3_to_v2.4_migration_prod_config.json

# Override config with command-line
python v2.3_to_v2.4_migration.py \
    --config v2.3_to_v2.4_migration_prod_config.json \
    --dry-run \
    --limit 100
```

### Using Runner Scripts

**PowerShell (Windows):**

```powershell
.\run_migration.ps1 v2.3_to_v2.4_migration_prod_config.json
```

**Bash (Linux/Mac):**

```bash
./run_migration.sh v2.3_to_v2.4_migration_prod_config.json
```

### Command Line Options

```
--config              : Path to configuration JSON file
--auth-table          : Source AuthEntitiesTable name (required)
--constraints-table   : Target ConstraintsStorageTable name (required)
--delete-old-data     : Delete constraints from old table after migration
--dry-run             : Test without making changes
--limit               : Maximum number of constraints to migrate (for testing)
--batch-size          : Batch size for DynamoDB operations (default: 25, max: 25)
--profile             : AWS profile name
--region              : AWS region
--log-level           : DEBUG, INFO, WARNING, ERROR (default: INFO)
```

## Migration Process Details

### Phase 1: Scan Old Table

1. Scans `AuthEntitiesTable` for all items where:
    - `entityType = 'constraint'`
    - `sk` begins with `'constraint#'`
2. Paginates through all results
3. Tracks total count

**Example Output:**

```
üìñ PHASE 1: Scanning old table for constraints...
Scanning vams-AuthEntitiesTable for constraints...
Found 25 constraints in old table
```

### Phase 2: Transform Data

Transforms each constraint from old schema to new schema:

**Old Schema:**

```json
{
    "entityType": "constraint",
    "sk": "constraint#admin-allow-all-apis",
    "constraintId": "admin-allow-all-apis",
    "name": "admin-allow-all-apis",
    "description": "Allow all API access for admin",
    "objectType": "api",
    "criteriaAnd": [{ "field": "route__path", "operator": "contains", "value": ".*" }],
    "groupPermissions": [{ "groupId": "admin", "permission": "GET", "permissionType": "allow" }]
}
```

**New Schema:**

```json
{
    "constraintId": "admin-allow-all-apis",
    "name": "admin-allow-all-apis",
    "description": "Allow all API access for admin",
    "objectType": "api",
    "criteriaAnd": "[{\"field\":\"route__path\",\"operator\":\"contains\",\"value\":\".*\"}]",
    "criteriaOr": "[]",
    "groupPermissions": "[{\"groupId\":\"admin\",\"permission\":\"GET\",\"permissionType\":\"allow\"}]",
    "userPermissions": "[]",
    "groupIds": ["admin"],
    "userIds": [],
    "dateCreated": "2024-12-08T19:30:00Z",
    "dateModified": "2024-12-08T19:30:00Z",
    "createdBy": "MIGRATION",
    "modifiedBy": "MIGRATION"
}
```

**Key Transformations:**

-   ‚úÖ Removed `entityType` and `sk` (no longer needed)
-   ‚úÖ Converted arrays to JSON strings (`criteriaAnd`, `criteriaOr`, `groupPermissions`, `userPermissions`)
-   ‚úÖ Extracted StringSets for GSI (`groupIds`, `userIds`)
-   ‚úÖ Added metadata fields (`dateCreated`, `dateModified`, `createdBy`, `modifiedBy`)

**Example Output:**

```
üîÑ PHASE 2: Transforming 25 constraints to new format...
Transformation complete: 25 success, 0 errors
```

### Phase 3: Write to New Table

1. Checks if each constraint already exists in target table
2. Skips existing constraints (e.g., default constraints created by CDK)
3. Batch writes only new constraints (25 items per batch)
4. Handles unprocessed items
5. Tracks success/failure/skipped counts

**Example Output (with existing constraints):**

```
üíæ PHASE 3: Writing constraints to new table...
Writing 25 constraints to vams-ConstraintsStorageTable...
Checking for existing records to avoid duplicates...
Skipped 8 existing constraints (already in new table)
Writing 17 new constraints...
Batch 1/1: Wrote 17 constraints
Write complete: 17 success, 0 failures, 8 skipped (already exist)
```

**Example Output (all new constraints):**

```
üíæ PHASE 3: Writing constraints to new table...
Writing 25 constraints to vams-ConstraintsStorageTable...
Checking for existing records to avoid duplicates...
Writing 25 new constraints...
Batch 1/1: Wrote 25 constraints
Write complete: 25 success, 0 failures, 0 skipped (already exist)
```

**Note**: The script automatically skips constraints that already exist in the target table, making it safe to re-run the migration multiple times.

### Phase 4: Optional Cleanup

Only runs if `--delete-old-data` flag is set:

1. Batch deletes from `AuthEntitiesTable` (25 items per batch)
2. Only deletes successfully migrated constraints
3. Tracks deletion counts

**Example Output (with --delete-old-data):**

```
üóëÔ∏è PHASE 4: Deleting constraints from old table...
Deleting 25 constraints from vams-AuthEntitiesTable...
Batch 1/1: Deleted 25 constraints
Deletion complete: 25 success, 0 failures
```

**Example Output (without --delete-old-data):**

```
‚è≠Ô∏è PHASE 4: Skipping deletion (--delete-old-data not specified)
Old constraint data remains in AuthEntitiesTable for safety
```

### Phase 5: Verification

Verifies migration success:

1. Counts constraints in old table
2. Counts constraints in new table
3. Compares with expected values
4. Reports any discrepancies

**Example Output:**

```
‚úÖ PHASE 5: Verifying migration...
Verifying migration...
Old table (vams-AuthEntitiesTable): 0 constraints
New table (vams-ConstraintsStorageTable): 25 constraints
‚úÖ Verification PASSED
```

## Monitoring

### Real-Time Progress

The script displays detailed progress:

```
================================================================================
VAMS v2.3 to v2.4 CONSTRAINTS TABLE MIGRATION
================================================================================
Source Table: vams-AuthEntitiesTable
Target Table: vams-ConstraintsStorageTable
Delete Old Data: False
Dry Run: False
================================================================================

üìñ PHASE 1: Scanning old table for constraints...
Found 25 constraints in old table

üîÑ PHASE 2: Transforming 25 constraints to new format...
Transformation complete: 25 success, 0 errors

üíæ PHASE 3: Writing constraints to new table...
Batch 1/1: Wrote 25 constraints
Write complete: 25 success, 0 failures

‚è≠Ô∏è PHASE 4: Skipping deletion (--delete-old-data not specified)

‚úÖ PHASE 5: Verifying migration...
‚úÖ Verification PASSED

================================================================================
MIGRATION SUMMARY
================================================================================
Migration Duration: 5.2 seconds
Constraints Found: 25
Transformation Errors: 0
Write Success: 25
Write Failures: 0
Dry Run: False
Status: ‚úÖ SUCCESS
================================================================================
```

### CloudWatch Logs

After migration, monitor authorization performance:

```bash
# Check authorization queries are using new table
aws logs filter-log-events \
  --log-group-name /aws/lambda/your-auth-function \
  --filter-pattern "Retrieved.*constraints.*optimized queries"

# Check for any authorization errors
aws logs filter-log-events \
  --log-group-name /aws/lambda/your-auth-function \
  --filter-pattern "ERROR"
```

### Log Files

Runner scripts automatically save logs:

```
logs/
‚îú‚îÄ‚îÄ migration_20241208_193000.log
‚îî‚îÄ‚îÄ migration_20241208_194500.log
```

## Troubleshooting

### Table Not Found

**Symptom**: "Table 'xxx' not found"

**Solution**: Verify table names from CloudFormation:

```bash
aws cloudformation describe-stacks \
  --stack-name your-vams-stack \
  --query 'Stacks[0].Outputs[?contains(OutputKey, `Table`)].{Key:OutputKey,Value:OutputValue}' \
  --output table
```

### Permission Errors

**Symptom**: "Access denied" or "User is not authorized"

**Solution**: Ensure your IAM user/role has the required DynamoDB permissions (see Prerequisites section).

### Transformation Errors

**Symptom**: "Error transforming constraint X"

**Solutions**:

1. Check constraint data format in old table
2. Run with `--log-level DEBUG` for detailed error messages
3. Use `--limit 1` to test single constraint transformation
4. Check CloudWatch logs for constraint service errors

### Write Failures

**Symptom**: "Write Failures: X" in summary

**Solutions**:

1. Check DynamoDB write capacity (may need to increase)
2. Verify target table exists and is accessible
3. Check for duplicate constraintIds
4. Re-run migration (idempotent - safe to retry)

### Verification Failures

**Symptom**: "Verification FAILED - counts don't match"

**Solutions**:

1. Check if migration completed successfully
2. Verify no constraints were added/deleted during migration
3. Re-run migration to sync any missing items
4. Check CloudWatch logs for errors

## Rollback

If migration fails or issues are discovered:

### Option 1: Re-run Migration

Migration is idempotent - safe to re-run:

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable
```

### Option 2: Clear New Table and Re-migrate

If new table has incorrect data:

```bash
# Manually clear new table via AWS Console or CLI
# Then re-run migration
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable
```

### Option 3: Restore from Old Table

If old data wasn't deleted (recommended):

1. Old constraints remain in `AuthEntitiesTable`
2. Can manually copy back if needed
3. Or re-deploy v2.3 CDK stack

**Important**: Always keep old data until thoroughly verified!

## Performance Considerations

### Small Deployments (< 50 constraints)

-   Migration completes in seconds
-   No special considerations needed

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable
```

### Medium Deployments (50-500 constraints)

-   Migration completes in under a minute
-   Monitor progress in real-time

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --log-level INFO
```

### Large Deployments (> 500 constraints)

-   May take several minutes
-   Consider using `--limit` for initial testing
-   Monitor DynamoDB write capacity

```bash
# Test with subset first
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --limit 100 \
    --dry-run

# Then run full migration
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable
```

## Data Deletion Considerations

### When to Delete Old Data

**Recommended Timeline:**

1. **Day 1**: Run migration without deletion
2. **Day 2-7**: Thoroughly test authorization in production
3. **After 1 week**: If no issues, run with `--delete-old-data`

**Benefits of Keeping Old Data:**

-   ‚úÖ Easy rollback if issues discovered
-   ‚úÖ Can compare old vs new data
-   ‚úÖ No risk of data loss
-   ‚úÖ Minimal storage cost

**Benefits of Deleting Old Data:**

-   ‚úÖ Cleaner database
-   ‚úÖ Reduced storage costs (minimal)
-   ‚úÖ No confusion about which table is active

### How to Delete Old Data

**Step 1: Verify migration success**

```bash
# Check new table has all constraints
aws dynamodb scan \
  --table-name vams-ConstraintsStorageTable \
  --select COUNT

# Check old table constraint count
aws dynamodb scan \
  --table-name vams-AuthEntitiesTable \
  --filter-expression "entityType = :type" \
  --expression-attribute-values '{":type":{"S":"constraint"}}' \
  --select COUNT
```

**Step 2: Test deletion with dry-run**

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --delete-old-data \
    --dry-run
```

**Step 3: Perform actual deletion**

```bash
python v2.3_to_v2.4_migration.py \
    --auth-table vams-AuthEntitiesTable \
    --constraints-table vams-ConstraintsStorageTable \
    --delete-old-data
```

## Migration Checklist

-   [ ] Deploy v2.4 CDK stack (creates default constraints automatically)
-   [ ] Check if you have custom constraints (see "Important Note" section)
-   [ ] If only default constraints exist, **skip migration** (CDK already created them)
-   [ ] If custom constraints exist, proceed with migration:
    -   [ ] Get table names from CloudFormation outputs
    -   [ ] Update configuration file with actual table names
    -   [ ] Run dry-run: `--dry-run --limit 10`
    -   [ ] Run production migration (without deletion)
    -   [ ] Verify authorization works correctly
    -   [ ] Test constraint management UI
    -   [ ] Monitor CloudWatch logs for 24-48 hours
    -   [ ] (Optional) Run migration with `--delete-old-data` after verification

## Expected Results

### Before Migration

-   Constraints stored in `AuthEntitiesTable` with `entityType = 'constraint'`
-   Authorization uses table scans (slow)
-   Cache persists for 15-30 minutes

### After Migration

-   Constraints stored in `ConstraintsStorageTable` with optimized schema
-   Authorization uses GSI queries (20-100x faster)
-   Cache expires reliably every 30 seconds
-   Old data optionally kept in `AuthEntitiesTable` for safety

## Support

For issues or questions:

1. Check migration logs in `logs/` directory
2. Run with `--log-level DEBUG` for verbose output
3. Test with `--dry-run` and `--limit` flags first
4. Verify table names are correct
5. Check IAM permissions

## Schema Comparison

### Old Schema (AuthEntitiesTable)

```
Primary Key: entityType (PK), sk (SK)
Attributes:
  - entityType: "constraint"
  - sk: "constraint#<constraintId>"
  - constraintId: String
  - name: String
  - description: String
  - objectType: String
  - criteriaAnd: List (array)
  - criteriaOr: List (array)
  - groupPermissions: List (array)
  - userPermissions: List (array)

Query Method: Table scan with FilterExpression
Performance: O(n) - scans all items
```

### New Schema (ConstraintsStorageTable)

```
Primary Key: constraintId (PK only)
Attributes:
  - constraintId: String
  - name: String
  - description: String
  - objectType: String
  - criteriaAnd: String (JSON)
  - criteriaOr: String (JSON)
  - groupPermissions: String (JSON)
  - userPermissions: String (JSON)
  - groupIds: StringSet (for GSI)
  - userIds: StringSet (for GSI)
  - dateCreated: String (ISO timestamp)
  - dateModified: String (ISO timestamp)
  - createdBy: String
  - modifiedBy: String

GSIs:
  - GroupPermissionsIndex: groupId (PK), objectType (SK)
  - UserPermissionsIndex: userId (PK), objectType (SK)
  - ObjectTypeIndex: objectType (PK), constraintId (SK)

Query Method: GSI queries
Performance: O(log n) - indexed lookups
```

## MCP Servers Used

This implementation utilized the following MCP servers:

-   awslabs.aws-iac-mcp-server (CDK and DynamoDB best practices)
-   awslabs.aws-documentation-mcp-server (AWS service documentation)
